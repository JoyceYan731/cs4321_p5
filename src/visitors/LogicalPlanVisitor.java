package visitors;
import java.util.HashSet;
import java.util.Map;


import data.TablePair;
import data.UfCollection;
import net.sf.jsqlparser.expression.Expression;
import net.sf.jsqlparser.expression.operators.conditional.AndExpression;
import logicalOperators.*;

/**
 * This class is to visit the logical plan generated by LogicalPlanBuilder. Starting from the root 
 * logical Operator in the logical plan, and visit the whole logical plan while inserting scan conditions and 
 * join conditions as the fields into the corresponding operators.
 * 
 * @author Ruoxuan Xu
 *
 */

public class LogicalPlanVisitor {
	private Map<String, Expression> scanConditions;
	private Map<TablePair, Expression> joinConditions;
	
	/**
	 * Constructor: construct a LogicalPlanVisitor instance by an
	 * ExpressionClassifyVisitor instance classifier. From classifier this class can get
	 * access to the map between tables and their scan conditions, as well as the map
	 * between table pairs and their join conditions.
	 * 
	 * @param classifier: the instance of ExpressionClassifyVisitor instance
	 */
	public LogicalPlanVisitor (ExpressionClassifyVisitor classifier) {
		/* get the expression conditions from ps. */
		if (classifier != null) {
			this.scanConditions = classifier.getScanConditions();
			this.joinConditions = classifier.getJoinConditions();
		}
	}
	
	/**
	 * Visit the LogicalScanOperatro scOp, and check if there is an expression 
	 * corresponding to the table alias of scOp is in scanConditions. If such expression
	 * exists, insert this expression into scOp and remove it from scanConsitions.
	 * 
	 * @param scOp
	 */
	public void visit(LogicalScanOperator scOp) {
		String tableAlias = scOp.getTableAliase();
		Expression ex = scanConditions.get(tableAlias);
		if (ex != null) {
			scOp.setExpression(ex);
			scanConditions.remove(tableAlias);
		}
	}
	
	/**
	 * When visiting the LogicalJoinOperator jnOp, visit its left child and right child before
	 * check join conditions of jnOp. 
	 * 
	 * For every entry <table pair, expression> in joinConditions, if two tables of table pair
	 * are both in the tableList of jnOp, then this expression should be put as joinConditions of jnOp, 
	 * and should be removed from joinConditions.
	 * 
	 * @param jnOp
	 */
	
	public void visit(LogicalJoinOperator jnOp) {
		/** p4 update: if it is an abstract logical join operator, 
		 * that is, a logical join with multiple children*/
		if (jnOp.getChildList() != null) {  
			
			jnOp.setUfCollection(ufc);
			
			for (LogicalOperator op : jnOp.getChildList()) {
				op.accept(this);
			}
			jnOp.setJoinConditions(joinConditions);
			return;
		}
		
		/**
		 * p1 - p3 implementation of logical join Operators
		 */
		LogicalOperator op1 = jnOp.getLeftChild();
		if (op1 != null) {
			op1.accept(this);
		}
		LogicalOperator op2 = jnOp.getRightChild();
		if (op2 != null) {
			op2.accept(this);
		}
		
		Expression expr = null;
		HashSet<TablePair> removeList = new HashSet<TablePair>();
		for(TablePair tbpir: joinConditions.keySet()) {
			if (jnOp.getAllTable().contains(tbpir.first()) && jnOp.getAllTable().contains(tbpir.second())) {
				if (expr == null) {
					expr = joinConditions.get(tbpir);
				} else {
					expr = new AndExpression(expr, joinConditions.get(tbpir));
				}
			    removeList.add(tbpir);
			}
		}
		for (TablePair tbpir: removeList) {
			joinConditions.remove(tbpir);
		}
		jnOp.setExpression(expr);		
	}
	
	/**
	 * When visiting the LogicalProjectOperator operator, visit its child.
	 * @param operator
	 */
	public void visit(LogicalProjectOperator operator) {
		LogicalOperator op1 = operator.getLeftChild();
		if (op1 != null) {
			op1.accept(this);
		}		
	}
	
	/**
	 * When visiting the LogicalSortOperator operator, visit its child.
	 * @param operator
	 */
	public void visit(LogicalSortOperator operator) {
		LogicalOperator op1 = operator.getLeftChild();
		if (op1 != null) {
			op1.accept(this);
		}	
	}

	/**
	 * When visiting the LogicalDuplicateEliminationOperator operator, visit its child.
	 * @param operator
	 */
	public void visit(LogicalDuplicateEliminationOperator operator) {
		LogicalOperator op1 = operator.getLeftChild();
		if (op1 != null) {
			op1.accept(this);
		}		
	}
	
	
	
	private UfCollection ufc;
	
	/**
	 * get the union-find collection
	 * @return
	 */
	public UfCollection getUfCollection () {
		return ufc;
	}
	
	/**
	 * set the union-find collection
	 * @return
	 */
	public UfCollection setUfCollection (UfCollection collection) {
		return ufc = collection;
	}
	
}
